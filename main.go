package main

import (
	"embed"
	"fmt"
	"io/fs"
	"net/http"
	"os"
	"os/signal"
	"syscall"

	"github.com/elga-io/redir/server"
	"github.com/gorilla/handlers"

	// docs is generated by Swag CLI.
	_ "github.com/elga-io/redir/docs"

	httpSwagger "github.com/swaggo/http-swagger"

	"github.com/prometheus/client_golang/prometheus/promhttp"

	"github.com/go-kit/log"
)

//go:embed ui/dist
//go:embed ui/dist/_next
//go:embed ui/dist/_next/static/chunks/pages/*.js
//go:embed ui/dist/_next/static/*/*.js
var nextFS embed.FS

func main() {
	logger := server.NewLogger()
	config := server.NewConfig(logger, ".")

	database := server.InitDatabase(logger, config)
	cache := server.InitCache()

	// Make database migration.
	database.AutoMigrate(server.Account{}, server.URL{})

	// Web UI
	ui := initWebUI(logger)

	// Create all services: auth, account and URL.
	var service server.Service
	service = server.NewService(config.SecretKey, database, cache)

	// Register APIs endpoint.
	mux := http.NewServeMux()
	mux.Handle("/api/v1/", handlers.LoggingHandler(os.Stdout, server.MakeHTTPHandler(service)))

	// Register Docs and Telemetry handlers.
	mux.HandleFunc("/swagger/", httpSwagger.WrapHandler)
	http.Handle("/metrics", promhttp.Handler())

	// For last, start endpoint for Web UI.
	mux.Handle("/", ui)
	http.Handle("/", server.AccessControl(mux))

	startServer(logger, &config.ServerAddress)
}

func envString(env, fallback string) string {
	e := os.Getenv(env)
	if e == "" {
		return fallback
	}
	return e
}

func initWebUI(logger log.Logger) (ui http.Handler) {
	distFS, err := fs.Sub(nextFS, "ui/dist")
	ui = http.FileServer(http.FS(distFS))

	if err != nil {
		logger.Log("exit", err)
		os.Exit(2)
	}
	return
}

func startServer(logger log.Logger, httpAddr *string) {
	errs := make(chan error, 2)
	go func() {
		logger.Log("transport", "http", "address", *httpAddr, "msg", "listening")
		errs <- http.ListenAndServe(*httpAddr, nil)
	}()
	go func() {
		c := make(chan os.Signal)
		signal.Notify(c, syscall.SIGINT)
		errs <- fmt.Errorf("%s", <-c)
	}()

	logger.Log("terminated", <-errs)
}
