package main

import (
	"embed"
	"flag"
	"fmt"
	"io/fs"
	"net/http"
	"os"
	"os/signal"
	"syscall"

	"github.com/elga-io/redir/server"
	"github.com/gorilla/handlers"

	// docs is generated by Swag CLI.
	_ "github.com/elga-io/redir/docs"

	httpSwagger "github.com/swaggo/http-swagger"

	"github.com/prometheus/client_golang/prometheus/promhttp"

	"github.com/go-kit/log"
)

//go:embed ui/dist
//go:embed ui/dist/_next
//go:embed ui/dist/_next/static/chunks/pages/*.js
//go:embed ui/dist/_next/static/*/*.js
var nextFS embed.FS

const (
	defaultPort   = "8080"
	defaultDBFile = "gorm.db"

	defaultSecretKey = "SUPER_SECRET_KEY"
)

// @title URL API
// @version 0.0.1
// @description Micro-serice for managing URL
// @termsOfService http://elga.io/terms
// @contact.name API Support
// @contact.email support@elga.io
// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html
// @host localhost:8080
// @BasePath /
func main() {
	var (
		addr = envString("REDIR_PORT", defaultPort)
		dbf  = envString("REDIR_DB", defaultDBFile)
		ssk  = envString("REDIR_SECRET_KEY", defaultSecretKey)

		httpAddr  = flag.String("http.addr", ":"+addr, "HTTP listen address")
		dbFile    = flag.String("db.file", dbf, "Database file")
		secretKey = flag.String("secret.key", ssk, "Secret key for encrypt and decrypt JWT")
	)
	flag.Parse()

	// Start logger, database and cache.
	logger := server.InitLogger()
	database := server.InitDatabase(logger, dbFile)
	cache := server.InitCache()

	// Make database migration.
	database.AutoMigrate(server.Account{}, server.URL{})

	// Web UI
	ui := initWebUI(logger)

	// Create all services: auth, account and URL.
	var service server.Service
	service = server.NewService(*secretKey, database, cache)

	// Register APIs endpoint.
	mux := http.NewServeMux()
	mux.Handle("/api/v1/", handlers.LoggingHandler(os.Stdout, server.MakeHTTPHandler(service)))

	// Register Docs and Telemetry handlers.
	mux.HandleFunc("/swagger/", httpSwagger.WrapHandler)
	http.Handle("/metrics", promhttp.Handler())

	// For last, start endpoint for Web UI.
	mux.Handle("/", ui)
	http.Handle("/", server.AccessControl(mux))

	startServer(logger, httpAddr)
}

func envString(env, fallback string) string {
	e := os.Getenv(env)
	if e == "" {
		return fallback
	}
	return e
}

func initWebUI(logger log.Logger) (ui http.Handler) {
	distFS, err := fs.Sub(nextFS, "ui/dist")
	ui = http.FileServer(http.FS(distFS))

	if err != nil {
		logger.Log("exit", err)
		os.Exit(2)
	}
	return
}

func startServer(logger log.Logger, httpAddr *string) {
	errs := make(chan error, 2)
	go func() {
		logger.Log("transport", "http", "address", *httpAddr, "msg", "listening")
		errs <- http.ListenAndServe(*httpAddr, nil)
	}()
	go func() {
		c := make(chan os.Signal)
		signal.Notify(c, syscall.SIGINT)
		errs <- fmt.Errorf("%s", <-c)
	}()

	logger.Log("terminated", <-errs)
}
